<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Plus Grid — Thin Stroke</title>
<style>
  :root{
    --margin: 20px;          /* viewport margin on all sides */
    --bg: #ffffff;           /* page background */
    --plus-off: #DEDEDE;     /* default stroke color */
    --plus-on:  #7D97EB;     /* hover stroke color */
    --stroke: 2px;           /* ≈ 1.5pt */
    --cell: 28px;            /* cell box size */
    --gap: 10px;             /* spacing between cells */
    --arm: 8px;              /* half-length of plus arms */
  }

  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: var(--bg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }

  /* Fill viewport with a 20px margin box */
  .wrap {
    position: fixed;
    inset: var(--margin);
    display: grid;
    place-items: center;
    box-sizing: border-box;
    background: transparent;
  }

  /* Grid fills the available box */
  .grid {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: repeat(var(--cols, 1), var(--cell));
    grid-auto-rows: var(--cell);
    gap: var(--gap);
  }

  .dot {
    width: var(--cell);
    height: var(--cell);
    display: grid;
    place-items: center;
    user-select: none;
  }

  svg {
    width: var(--cell);
    height: var(--cell);
    overflow: visible;
  }

  .plus line {
    stroke: var(--plus-off);
    stroke-width: var(--stroke);
    stroke-linecap: round;
    transition: stroke .15s linear, opacity .35s ease, filter .2s ease;
    opacity: .9;
  }

  .dot:hover .plus line,
  .dot._active .plus line {
    stroke: var(--plus-on);
    opacity: 1;
    filter: drop-shadow(0 0 6px rgba(125,151,235,.45)) drop-shadow(0 0 14px rgba(125,151,235,.2));
  }

  @media (max-width: 700px){
    :root { --cell: 22px; --gap: 8px; --arm: 6px; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="grid" id="grid" aria-hidden="true"></div>
  </div>

<script>
  // Parameters pulled from CSS custom properties
  const css = getComputedStyle(document.documentElement);
  const grid = document.getElementById('grid');

  function num(val){ return parseFloat(val); }

  function readVars(){
    return {
      cell:  num(css.getPropertyValue('--cell')),
      gap:   num(css.getPropertyValue('--gap')),
      arm:   num(css.getPropertyValue('--arm'))
    };
  }

  function calcColsRows(){
    const {cell, gap} = readVars();
    const rect = grid.getBoundingClientRect();
    const cols = Math.max(1, Math.floor((rect.width  + gap) / (cell + gap)));
    const rows = Math.max(1, Math.floor((rect.height + gap) / (cell + gap)));
    return {cols, rows};
  }

  function makePlus(arm){
    // SVG plus at center with controlled stroke width
    const svgNS = 'http://www.w3.org/2000/svg';
    const s = document.createElementNS(svgNS, 'svg');
    s.setAttribute('viewBox', '-12 -12 24 24'); // centered coordinate system

    const g = document.createElementNS(svgNS, 'g');
    g.setAttribute('class', 'plus');

    const h = document.createElementNS(svgNS, 'line');
    h.setAttribute('x1', -arm); h.setAttribute('y1', 0);
    h.setAttribute('x2',  arm); h.setAttribute('y2', 0);

    const v = document.createElementNS(svgNS, 'line');
    v.setAttribute('x1', 0); v.setAttribute('y1', -arm);
    v.setAttribute('x2', 0); v.setAttribute('y2',  arm);

    g.appendChild(h); g.appendChild(v);
    s.appendChild(g);
    return s;
  }

  let lastCols = 0, lastRows = 0;

  function build(){
    const {cols, rows} = calcColsRows();
    if (cols === lastCols && rows === lastRows) return;
    lastCols = cols; lastRows = rows;

    // Update CSS var for columns so the grid template matches
    grid.style.setProperty('--cols', cols);

    // Build cells
    const {arm} = readVars();
    const frag = document.createDocumentFragment();
    for (let i = 0; i < cols * rows; i++){
      const cell = document.createElement('div');
      cell.className = 'dot';
      cell.appendChild(makePlus(arm));
      frag.appendChild(cell);
    }
    grid.replaceChildren(frag);
  }

  // Optional "flashlight" radius to softly light nearby pluses
  const R = 55;
  let gridRect = grid.getBoundingClientRect();

  function refreshRect(){ gridRect = grid.getBoundingClientRect(); }

  function enableFlashlight(){
    grid.addEventListener('mousemove', (e)=>{
      const x = e.clientX - gridRect.left;
      const y = e.clientY - gridRect.top;
      for (const cell of grid.children){
        const r = cell.getBoundingClientRect();
        const cx = r.left - gridRect.left + r.width/2;
        const cy = r.top  - gridRect.top  + r.height/2;
        const active = Math.hypot(cx - x, cy - y) < R;
        cell.classList.toggle('_active', active);
      }
    });
    grid.addEventListener('mouseleave', ()=>{
      for (const cell of grid.children){ cell.classList.remove('_active'); }
    });
  }

  // Build and keep responsive
  const ro = new ResizeObserver(()=>{ refreshRect(); build(); });
  ro.observe(grid);
  window.addEventListener('resize', ()=>{ refreshRect(); build(); });

  build();
  refreshRect();
  enableFlashlight();
</script>
</body>
</html>

